package execution

import (
	"errors"

	common "github.com/arcology-network/common-lib/common"
	"github.com/arcology-network/common-lib/exp/array"
	"github.com/arcology-network/eu/execution"
	evmcore "github.com/ethereum/go-ethereum/core"

	arbitrator "github.com/arcology-network/concurrenturl/arbitrator"
	ccurlcommon "github.com/arcology-network/concurrenturl/common"
	"github.com/arcology-network/concurrenturl/univalue"
	schedule "github.com/arcology-network/eu/new-scheduler"
	intf "github.com/arcology-network/vm-adaptor/interface"
)

// APIs under the concurrency namespace
type Generation struct {
	ID         uint32
	numThreads uint8
	jobSeqs    []*JobSequence // para jobSeqs
	sch        *schedule.Schedule
}

func NewGeneration(id uint32, numThreads uint8, jobSeqs []*JobSequence, sch *schedule.Schedule) *Generation {
	return &Generation{
		ID:         id,
		numThreads: numThreads,
		jobSeqs:    jobSeqs,
		sch:        sch,
	}
}

// This function converts a list of raw calls to a list of parallel job sequences. One job sequence is created for each caller.
// If there are N callers, there will be N job sequences. There sequences will be later added to a generation and executed in parallel.
func NewGenerationFromCalls(id uint32, numThreads uint8, evmMsgs []*evmcore.Message, api intf.EthApiRouter, sch *schedule.Schedule) *Generation {
	gen := NewGeneration(id, uint8(len(evmMsgs)), []*JobSequence{}, sch)
	array.Foreach(evmMsgs, func(i int, msg **evmcore.Message) {
		gen.Add(new(JobSequence).NewFromCall(*msg, api))
	})
	return gen
}

// NEED to inject to the write cache

// func (this *Generation) BranchID() uint32 { return this.branchID }
func (this *Generation) Length() uint64     { return uint64(len(this.jobSeqs)) }
func (this *Generation) JobT() *JobSequence { return &JobSequence{} }
func (this *Generation) JobSeqs() []*JobSequence {
	return array.To[*JobSequence, *JobSequence](this.jobSeqs)
}

func (this *Generation) At(idx uint64) *JobSequence {
	return common.IfThenDo1st(idx < uint64(len(this.jobSeqs)), func() *JobSequence { return this.jobSeqs[idx] }, nil)
}

func (*Generation) New(id uint32, numThreads uint8, jobSeqs []*JobSequence, sch *schedule.Schedule) *Generation {
	return NewGeneration(id, numThreads, array.To[*JobSequence, *JobSequence](jobSeqs), sch)
}

func (this *Generation) Add(job *JobSequence) bool {
	this.jobSeqs = append(this.jobSeqs, job)
	return true
}

// The run function executes the job sequences in parallel and returns the results in a single array.
// The parentApiRouter is used to access the state data. For external transaction execution, the parentApiRouter has
// all the state data from the last block. For the spawned transaction execution, the parentApiRouter has the state data
// of it parent thread up to the point of the point of the thread creation. The child thread uses the state data of the parent
// thread to create a state snapshot for itself. Eventually, all the state changes generated by the child threads will be
// merged back into the parent thread.
//
// But when a child thread is trying to deploy a contract, it needs to increment the nonce of the caller contract and
// the nonce is a global counter for the account. Since there is no inter-thread communication, the child will increment
// the nonce of the parent thread by itself independently. Different child threads may deploy their contracts at the same address.

// This isn't a problem for the external transaction execution, the conflict detector will find it out and revert the transactions.
// But for the spawned transaction execution, sometimes we need to deploy some temporary contracts to do their jobs, and certainly we
// don't want to cause any conflict. That is why we need to give different nonceOffset to different child threads, so they can deploy
// their contracts at different addresses.

func (this *Generation) Execute(parentApiRouter intf.EthApiRouter) []*univalue.Univalue {
	config := execution.NewConfig().SetCoinbase(parentApiRouter.Coinbase())

	groupIDs := make([][]uint32, len(this.jobSeqs))
	records := make([][]*univalue.Univalue, len(this.jobSeqs))

	array.ParallelForeach(this.jobSeqs, int(this.numThreads), func(i int, _ **JobSequence) {
		groupIDs[i], records[i] = this.jobSeqs[i].Run(config, parentApiRouter, uint64(i+1))
	})

	// univalue.Univalues(records[0]).Print()
	// fmt.Println("")
	// univalue.Univalues(records[1]).Print()

	txDict, groupDict, _ := this.Detect(groupIDs, records).ToDict()
	return array.Concate(this.jobSeqs, func(seq *JobSequence) []*univalue.Univalue {
		if _, ok := groupDict[(*seq).ID]; ok {
			(*seq).FlagConflict(txDict, errors.New(ccurlcommon.WARN_ACCESS_CONFLICT))
		}
		return (*seq).GetClearedTransition()
	})
}

func (*Generation) Detect(groupIDs [][]uint32, records [][]*univalue.Univalue) arbitrator.Conflicts {
	if len(records) == 1 {
		return arbitrator.Conflicts{}
	}
	return arbitrator.Conflicts((&arbitrator.Arbitrator{}).Detect(array.Flatten(groupIDs), array.Flatten(records)))
}

func (this *Generation) Clear() uint64 {
	length := len(this.jobSeqs)
	this.jobSeqs = this.jobSeqs[:0]
	return uint64(length)
}
