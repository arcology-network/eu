<!-- ## Nonce  -->
- [What is Nonce](#what-is-nonce)
- [Why Change the Nonce Calculation for Contract-initiated Deployment?](#why-change-the-nonce-calculation-for-contract-initiated-deployment)
  - [1.2. Changes](#12-changes)
  - [1.2. Offsetting Nonce vs Offsetting Increment](#12-offsetting-nonce-vs-offsetting-increment)
  - [1.3. Calculating Offset Nonce](#13-calculating-offset-nonce)
  - [4.2. Example](#42-example)

## What is Nonce

In the context of Ethereum (ETH), a "nonce" refers to a number that is associated with a sender's address in a transaction. The term "nonce" is short for "number once." Each transaction from a specific address must have a unique nonce. Arcology Network uses a different nonce calculation method than Ethereum.

In Ethereum a nonce increments by 1 for each transaction sent by the EOA. For contract accounts, the nonce increments by 1 only when the contract creates a another contract. Arcology Network uses a different method to calculate the contract nonce.

## Why Change the Nonce Calculation for Contract-initiated Deployment?

The decision to change the nonce calculation method was made to support the following features of the Arcology Network:
- [Rollback](./rollback.md)
- [Multiprocessor](./multiprocess.md)

### 1.2. Changes

The new algorithm doesn't change the how the deployment address is calculated. The nonce still increments by 1 for each deployment, but the base value is replaced by a random nonce. So the one-to-one relationship between the nonce increment and the address is still pretty gone for the contract-initiated deployment.

The address calculation is still the same as the EVM, and the address conflict problem is solved.  For example, if the current nonce value is 10, it only means that the contract has deployed 10 contracts, and it doesn't mean the relationship between every nonce value and the deployment address still exists along the way.Instead, it changes the initial nonce. The initial nonce is the nonce used to calculate the deployment address.

### 1.2. Offsetting Nonce vs Offsetting Increment

We can either offset the initial nonce or the increment by a pseudo-random number. But because the increments generated by multiple transactions will need to be add up to the initial nonce to get the new nonce in the end. There are some problems with offsetting the increment.

- If the offset increment is too small, they are still likely to cause conflicts. 
  
- If the offset increment is too large, when being added together, the new nonce may even overflow.

The increments are still going to be compliant with current Ethereum rules. The final nonce after apply the increments is still identical to the as they were used with the standard deployment method. The initial nonce is offset by a pseudo-random number. This number is passed to the MP by the caller. The caller can generate this number using a hash function. The hash function can take the caller address and the current block number as input. This way, the number is unique for each MP-created transaction.

### 1.3. Calculating Offset Nonce

offset Nonce = hash(mp address, threadID)

This will ensure that the nonce is unique for every deployment initiated by a contract, even if the contract is rolled back. **Please note that this only applies to the contracts that deploy others. EOAs won't be affected at all.**

### 4.2. Example

Consider the following example: A multiprocessor creates 2 sub transactions. The initial nonce is 10. The offset is 50000 for the first sub transaction and 10000 for the second sub transaction. 

First sub transaction:
* Nonce: 10
* Offset: 50000
* Nonce with offset: 50000 + 10 = 50010
* Increment: 1

Second sub transaction:
* Nonce: 10
* Offset: 10000
* Nonce with offset: 10000 + 10 = 10010
* Increment: 1

In the deployments, 
* The first sub deployment has a nonce of 50010  + 1 = 50011.
* The second sub deployment has a nonce of 10010  + 1 = 10011.

In the commit phase, the initial nonce is removed, while keeping the nonce increment, the final nonce will be `10 + 1 + 1`. It is the same as the standard nonce calculation algorithm after two deployments on Ethereum.
